# SHA3

224, 256, 384, 512
SHAKE128,  SHAKE256

## 设计

Keccak 使用海绵函数，此函数会将资料与初始的内部状态做XOR运算，这是无可避免可置换的（inevitably permuted）。在最大的版本，算法使用的内存状态是使用一个5×5的二维数组，资料类型是64位的字节，总计1600比特 。缩版的算法使用比较小的，以2为幂次的字节大小w为1比特，总计使用25比特。除了使用较小的版本来研究加密分析攻击，比较适中的大小（例如从w=4使用100比特，到w=32使用800比特）则提供了比较实际且轻量的替代方案。 

## Keccak 的置换

置换方法是先定义字的长度为二的某次方，w = 2ℓ比特。SHA-3的主要应用使用64位的字长，ℓ = 6。
内存状态可以被视为5×5×w的三维数组。令a[i][j][k]代表内存状态的第(i×5 + j)×w + k个比特（使用小端序，little-endian，参见字节序）。
置换函数是五个子段落（sub-round）作12+2ℓ次的循环，每一个子段落都相当简单： 

## 海绵函数

海绵函数是由三个部分组成：[1]

    一个内存状态S，包含b个比特
    一个能置换或者转换内存状态，固定大小的转换函数 f
    一个填充函数（padding function）P

内存状态会分成两个区块， R （大小为 r比特）与 C（大小为 b − r 比特）。这里的参数  r又叫做转换率（bitrate），而 c叫做容量（capacity）。

填充函数会在输入里面增加足够的长度，让输入的比特流长度变成 r r的整数倍。因此填充过后的输入可以被切成长度为 r的数个分段。

然后，海绵函数运作如下：

    S先初始化为零
    输入经过填充函数处理
    填充后输入的前面 r r个比特会与R进行XOR运算
    S经过函数 f f转换成 f(S)
    如果填充后输入还有剩余，下一 r比特的分段与 R进行XOR运算
    S转换成 f(S)

这过程一直重复到所有的输入都用完为止（在海棉的譬喻里面，被函数“吸收”了）。

现在海绵函数可以依照如下的过程输出（“挤出”内容）：

    此时 R R里面的资料是输出的前面 r个比特
    如果需要更多输出，先把 S转换成 f ( S )
    此时R里面的资料是输出的下面 r个比特
    …

这过程会重复到满足输出所需要的长度为止。

这里值得注意的地方是，输入绝对不会与 C这部分的存储器作XOR运算，而且 C这一部分存储器也不会直接被输出。 C这一部分的存储器仅仅只和转换函数 f相关。在散列里面，防止撞击攻击（Collision attack）或者原像攻击（preimage attack）是依靠 C这段存储器作到的。一般实做上 C的大小会是所希望防止等级的两倍。 
# sha256

## 生日碰撞

是概率论中生日问题的数学原理。
举个例子，一位老师问一个有30名学生的班级（n = 30）每个人的生日在哪一天（为简便，此处省略闰年）以确定是否有两个学生同一天生日（对应碰撞 ）。从直觉角度考虑，机率看起来很小。若老师选择特定日期（例如9月16日），则至少有一名学生在那天出生的几率是1-(364/365)^30
，约为7.9%。但是，与我们的直觉相反的是，至少一名学生和另外任意一名学生有着相同生日的几率大约为70.63%（n = 30时），从方程 
    1-365!/(365-n)!*365^n
中可看出。

离散对数 Pollard Rho 算法是一项使用生日碰撞以计算离散对数的算法。


SHA256算法中用到了8个哈希初值以及64个哈希常量

初始哈希值[公式]取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分, 并且取前面的32位. 下面举个例子: 根号2小数部分约为0.414213562373095048, 
于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667

H0=0x6a09e667
.......
h7=0x5be0cd19

SHA256算法当中还使用到64个常数, 取自自然数中前面64个素数的立方根的小数部分的前32位, 如果用16进制表示, 则相应的常数序列如下:

428a2f98 71374491 b5c0fbcf e9b5dba5
3956c25b 59f111f1 923f82a4 ab1c5ed5
d807aa98 12835b01 243185be 550c7dc3
72be5d74 80deb1fe 9bdc06a7 c19bf174
e49b69c1 efbe4786 0fc19dc6 240ca1cc
2de92c6f 4a7484aa 5cb0a9dc 76f988da
983e5152 a831c66d b00327c8 bf597fc7
c6e00bf3 d5a79147 06ca6351 14292967
27b70a85 2e1b2138 4d2c6dfc 53380d13
650a7354 766a0abb 81c2c92e 92722c85
a2bfe8a1 a81a664b c24b8b70 c76c51a3
d192e819 d6990624 f40e3585 106aa070
19a4c116 1e376c08 2748774c 34b0bcb5
391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
748f82ee 78a5636f 84c87814 8cc70208
90befffa a4506ceb bef9a3f7 c67178f2


[和md5 大致相同]
对消息进行补码处理: 假设消息M的二进制编码长度为l位. 首先在消息末尾补上一位"1", 然后再补上k个"0", 其中k为下列方程的最小非负整数

l+1+k mod 512 = 448

另外, 考虑到最后要将消息长度l转换为64位二进制编码, 因此, 长度的必须小于2^64,
= 2048pb

将补码处理后的消息以512位为单位分块为: m1,m2.....mN, 其中第i个消息块的前32位表示为: Mi0, 后面32位为: mi1, 以此类推, 最后32位的消息块可表示为: mi15. 我们采用Big endian约定对数据进行编码, 即认为第一个字节是最高位字节, 因此, 对于每一个32位字节, 最最左边的比特是最大的比特位.


主要循环
for i = 1->N
    用第(i-1)个中间哈希值来对 a,b,c,d,e,f,g,h进行初始化, 当i=1时, 就使用初始化哈希, 即:
     a <- h1()
     b <- h2()
     .
     .
     h <- h8()

应用SHA256压缩函数来更新[a,b,c,d,e,f,g,h]
for k = 0 -> 63  #利用上面64个常数
    t1 <- h + E1(e) + ch(e,f,g) + k + w
    t2 <- E0(a) + Maj(a,b,c)
    h <- g
    g <- f
    f <- e
    e <- d+t1
    d <- c
    c <- b
    b <- a
    a <- t1+t2

计算第i个中间值 hi

    h1 <- a+h1  (i-1)次、
    h2 <- b+h2  (i-1)次、
    .
    .
    h8 <- b+h8  (i-1)次、

H(N) = (h1,h2,....h8) = 最终hash 结果


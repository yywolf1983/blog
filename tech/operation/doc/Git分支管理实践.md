# Git分支管理实践

Linux & Git 被称为 Linus Travis 的两大神作, 实至名归!!!

### 布道（在谈 Git 之前, 先谈一下 Linux.）

Linux 和 Windows 作为两个广泛使用的操作系统, 有着极大的差异, 在各种广泛的评价和争执中, 我对下面的评价十分赞同:

> Linux 与 Windows 最本质的区别在哪里。有人会说前者免费，后者需要买 (或偷)。这只是对 “free software” 的曲解。在我看来，二者最重要的区别乃是它们对自己的用户所做的假设。
>
> 对于 Linux，这个假设是：**用户知道自己想要什么，也明白自己在做什么，并且会为自己的行为负责。**
>
> 而 Windows 则恰好相反：**用户不知道自己想要什么，也不明白自己在做什么，更不打算为自己的行为负责。**

<!-- 我不晓得上述观点最初源自哪里, 或许是这里: [Zaikun's Blog](http://mat.uc.pt/~zhang/blog.html) -->

这两种理念没有谁是谁非, 孰优孰劣. 海纳百川, 有容乃大, 我会尝试发现每一种理念的优势和适用场景, 而不是一味地去否定什么.

- 在工作场景上, 我更喜欢 Linux 的理念:

我曾`rm -rf`误删过系统, 导致系统陷入瘫痪; 也曾因包管理依赖问题而导致软件损坏 ... 

在我看来, 这些都不可怕, Linux 会准确的向我展示**故障原因**, 而不是`请稍后...`, `我们正在做一些准备工作`

日复一日的使用, 我犯错误的概率越来越低, 对 Linux 本身的理解越来越深入, 对 Linux 越来越信任, 并且逐渐有了一种对 Linux 的掌控感.


Git 与 Linux 同源同宗, 亦是有着相似的理念, 其本身有着极为灵活的设计, Git 认为:
> **用户知道自己在做什么, 并且会为自己的行为负责。**

在开源领域的广泛使用中形成了三种被广泛接受的最佳实践: Git flow, Github flow, Gitlab flow, 可以参考 [Git 工作流程 - 阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html) 一文.

## 从手忙脚乱开始

当我初学 Git 时, 我关注 Git 的工程实践胜过其内在的设计理念, 以至于迫切的去寻找一些所谓的最佳实践, 然后僵硬地模仿甚至生搬硬套, 结果显而易见, 我始终无法做到

> flow，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡.

![Git Flow](https://images.gitee.com/uploads/images/2019/0620/203233_e4ab818d_1343639.png "git_flow.png")

理想是行云流水, 现实却往往惨不忍睹

## 静下心来想一想

收起急功近利的心态, 我开始思考, Git 的设计理念到底是什么.

Git 是一种版本控制系统, 先不谈 Git 是如何设计的, 如果让我来设计一个版本管理系统, 该如何下手?

### 设计一个最简单的版本控制系统

![版本控制 - 毕业论文](https://images.gitee.com/uploads/images/2019/0620/205013_18bf5bad_1343639.jpeg "timg.jpeg")

这就是一个简单粗暴的版本控制系统, 简单的文件拷贝加重命名已经能满足对于毕业论文的版本控制, 到最后, 能拿出一个漂亮的**毕业论文**终板即万事大吉.

上面的每一个版本都是基于上一个版本修改而来的, 并且当新的版本出来之后, 老旧版本的价值就几乎不存在了, 在使用 SVN 或者 Git 一个人开发小项目或记笔记的时候, 场景与此类似. 

### 如果场景复杂一点儿呢?

如果导师帮我一块改, 都基于`毕业论文最终版1.doc`修改, 导师改出了`C.doc`, 我改出了`D.doc`, 这时若想保留两人所有的修改, 并合并出一个新的版本`E.doc`, 似乎就要花些功夫了.

1. 首先要找出来导师改了哪些, 我改了哪些;
2. 然后基于`毕业论文最终版1.doc`, 把`导师的修改`和`我的修改`应用过来;

哈! 这不就是 `git merge` 嘛!

![git merge 事故现场](https://images.gitee.com/uploads/images/2019/0620/212428_dfe197c6_1343639.png "QQ20190620-212344.png")

不好意思, 图放错了

![输入图片说明](https://images.gitee.com/uploads/images/2019/0622/230840_ba7874db_1343639.png "QQ20190622-230816@2x.png")

### 关注点到底在哪里?

我们的关注点已经从**论文本身**转向了`修改`, 多人同时进行`修改`使得我必须小心处理每个人的`修改`, 不能**遗漏**, 不能**冲突**, 也不能**逻辑矛盾**, 这简直太混乱了:astonished:

## Git 的设计理念

### 理解 Commit

通过对上面的分析, 相信你已经体会, 的核心关注点应该是`修改`, 而不是`论文本身`. 

让思路回到 Git 上来, Git 分支图中的每个点由`git commit`命令产生, 并且会产生一个唯一的`sha1`值, 因此可以通过`sha1`值来唯一确定一个提交点.

使用`git checkout`命令我们可以在整个 Git 提交历史上的所有快照版本穿梭, 这就是git的特性`HEAD`指针, `git checkout`正是通过挪动`HEAD`指针来达到快照切换的目的, 如果多次穿梭后, 你迷失了自己, 找不到当前在哪一个快照, 请查看 Git 分支图, 找到`HEAD`指针, 这就是你所处的快照版本.

![git show](https://images.gitee.com/uploads/images/2019/0621/001717_90fc310c_1343639.png "QQ20190621-001702@2x.png")

可以看到, `git show`命令完整的展示了`B`点与其上有节点`A`点的差异, Git 作为一个面向源码的版本控制工具, 将差异以**行**为基本单位表示是比较合理的一个选择. 这也意味着将 Git 用于非文本资源的版本控制工具或许不是最佳选择.

对一个提交点含义的双重解释看上去很不错, 不过, 在这个分支图上, `E`点有点儿特殊, 只有`E`点有两个上游节点`C`和`D`, 尝试执行`git show [E]`, 发现并没有像其他节点一样, 显示出**diff**信息, 这说得过去, 不然到底该显示`E`和`C`的差异, 还是`E`和`D`的差异呢?

这时就只能借助 Git 的另一个命令`git diff [X] [Y]`来显式声明要比较任意两个节点`X`和`Y`的差异.

## 砖头有了, 城堡在哪呢?

### 日常一天

在现实一些项目组里, 你可能会被告诫道: "记得每天下班前提交下你的代码." 也许他们已经发现: "怎么代码又冲突了", "我写的代码怎么被覆盖了", 会对你多提一句告诫: "记得提交前先拉一下代码, 别把同事写的覆盖了". 于是, Git 就仅仅成为了一个`远程代码仓库`.

> 产品: "上次提的3个需求, 今天就上1个, 另外2个不用了"
>
> 开发: "我代码昨天都写完提交了, 那只能把2个需求代码删掉了. 我可是有代码洁癖的, 不能让我的项目里这么多无用代码留着"
> 
> [两小时后]
> 
> 产品: "我想了一下, B功能还是要上的, 一共上2个功能"
>
> 开发: "行吧, 我再把代码拷贝回来"
>
> [临上线]
>
> 产品: "不行, 下掉B功能, 上C功能! 快!!!"
>
> 开发: "W-- 我佛慈悲!"
>
> [上线后]
>
> 老大: "C功能有bug, 立刻回滚"
>
> 开发: "好, 我退回到上次发版的快照" 

这是日常的一天, 也是糟糕的一天, 大把的时间浪费在代码的删除和拷贝上, 而不是在创造上.

### 问题出在哪了?

上节我们提到, Git 每个 Commit 都有两种属性, **快照**和**补丁**. 在上面的使用场景中, Git 只发挥出了不到一层功力, 大家关注的仅仅是**最新提交点的快照**, 当然, 这个快照是极为重要的, 重要到我们的**HEAD指针**几乎总是在指向他, 重要到我们会把他称为**最新的master分支**.

我们把关注点转移到 Git 的**补丁**属性上来, 你每天提交的 commit 代表着你这一天的工作成果, 那么描述怎么写? 

"张三20190622工作"? 还是 "增加了A功能, B功能, C功能写了一半"

或许后者稍微好一点儿, 至少在几天时候查看 Git 提交记录时能一目了然的知道这次提交包含什么修改.

还记得`git diff`的输出吗? 是行级的差异. 为什么不是文件级别, 或者字符级别? 每次代码提交以天为单位真的合适吗? 当然不合适, 每个 commit 的最佳粒度应该是**相对独立的特性(feature)**, 比如上文提到的A, B, C三个功能.

理想情况下, A, B, C是三个独立的功能, 分别作为三次 commit.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0622/220236_a1e4c7af_1343639.png "QQ20190622-220219@2x.png")

### 更好的做法是什么?

还记得吗? A, B, C都是独立的补丁(patch), 那么A, B, C的次序是没有关系的, 也就是说`C1`, `B2`, `A3`的代码快照应该是一样的. 不信试一下, 可以用`git diff`验证结果.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0622/220740_c414a0fa_1343639.png "QQ20190622-220724@2x.png")

当要求撤掉 B 功能时, 如果可以直接删掉 B 这次提交, 那么瞬间就达到目的了. 但是, 有两点是需要考虑的:

1. 一般来说, 大家同时使用的分支只前进, 不后退, 即不能篡改历史;
2. 若真的篡改了历史, 那么 B 功能的代码就从提交记录上消失了, 万一需要再次添加 B 功能, 这将是悲剧.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0622/225426_527fd823_1343639.png "QQ20190622-225414@2x.png")

当要求把 B 功能加回来时, 是该祭出神器了吗?

![程序员专用键盘](https://images.gitee.com/uploads/images/2019/0622/203345_c3d8d77c_1343639.jpeg "Dodatkowa-klawiatura-ctrl-c-v-bardzo-obrazek_duzy_4027563.jpg")

既然这三种状态是等价的, 那么作为倾向于完美主义的我们, 更希望在 Git 提交历史上留下的是最后一种干净的状态. 但我已经在`B2`状态了, 怎么才能实现`C3`? 相信你已经想到了办法, 回到最初的检出点, 通过`cherry-pick`拾取`A`, `B`, `C`3个补丁, 即可创建一个干净的提交历史. 
### 重新认识分支

当提出A, B, C三个需求的时候, 如果分派给三个人, 每个人负责一个功能, 同时基于最新的代码开发, 那么将会进入这种状态

![输入图片说明](https://images.gitee.com/uploads/images/2019/0622/230327_cfc56cce_1343639.png "QQ20190622-230309@2x.png")

但是, 如果我们遵循`master`, `develop`分支模型开发, 那么永远不会在 Git 分支图上看到这种状态.

再次重申一下, 我们的关注点是`commit`, 用唯一的`sha1`标识, 他有两种含义`快照`和`补丁`.

我们主要讨论`分支(branch)`. 分支怎样前进呢?

- 当执行`git commit`后, 分支就前进了;

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/002630_74046722_1343639.png "QQ20190623-002618@2x.png")

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/002642_18d7f48a_1343639.png "QQ20190623-002540@2x.png")

- 执行`git merge`后, 分支会前进.

当 Git 关联到远程仓库时, 每个分支可以设置一个远程追踪分支`git branch --set-upstream-to=[origin]/[branch]`, 当执行`git fetch`, `git pull`, `git push`时, 默认都是在操作关联的远程分支. 一个本地 Git 仓库可以关联多个远程仓库, 习惯上默认仓库或者主仓库叫做`origin`.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/003936_56e8993d_1343639.png "QQ20190623-003922@2x.png")

当本地`master`分支落后远程`origin/master`分支时, 一般会执行`git pull`命令跟进, 但这后面到底发生了什么?

```text
git pull命令其实是个git fetch和git merge的组合命令。
git fetch是仅仅拉取远程分支的进度, 远程origin/master超前了本地master, 必然是执行了git fetch后才能看到, 
Git 的图形工具或者 IDE 会在后台定期做这项工作, 在远程分支更新后及时通知.
```

当`HEAD指针`在`master`时, 执行`git merge origin/master`, `master`即会前进到`origin/master`.

Merge 不是合并分支吗? 怎么变成了分支前进?

### 危险的 Merge

通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。

我把`git merge`定义为高危操作! 一般开发人员(非项目leader)应尽可能避免使用直接或间接使用该命令.

提到 Merge, 或许下面的这种场景是我们第一时间想到的:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/122448_a294004a_1343639.png "basic-branching-6.png")

当我处在`master`时, 也就是`HEAD指针`指向`master`, 执行`git merge iss53`: 若无冲突, 即会得到下图结果; 若有冲突, 则会提示手动解决, 然后作为一次新的 commit, 同样也会得到下图结果.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/122503_0b74c256_1343639.png "basic-merging-2.png")

也许你发现了, 这里分支图风格变化了, 不仅仅是画风的转变, 最重要的是**箭头方向**. 这两张图是我从 Git 官方文档复制过来的, 所以请不要质疑他的权威. 那么是我之前的箭头方向画错了吗? 

以上正是我把 merge 操作定义为**高危操作**的原因.

#### 危险抛给更有经验的人的
一般开发人员(非项目leader)应尽可能避免使用直接或间接使用该命令. 

### 理想的分支图

我们已经找到了一种来尽量避免 merge 风险的场景, 在这种场景下, 我们会构造出怎样的分支图?

如果我们使用`git merge --no-ff`参数, 结果将是这样的,

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/170741_e53383da_1343639.jpeg "160d8f9f7f24bd7a.jpg")

([如何优雅地使用 Git](https://juejin.im/post/5a54386af265da3e3b7a6317))


## 画重点
对于大规模的项目来讲, 每一个对于master commit 都不是随意的, 邮件列表, Github Issue 列表等诸如此类的讨论, 明确 commit 的功能和影响, 确保每个 Commit 只做一件事, 变动最小化, 然后通过 Pull Request 方式请求合并至主仓库的主线分支. 在这种情况下, 使用`--no-ff`的话, 几乎每个 commit 都会产生一个空的 merge 节点, 分支图就变成了锯齿状, 带来的收益微乎其微; 而规范 commit 注释, 并且使用 fast-forward **或许**是一个更好的选择:smile:.

对于需要快速响应变化的公司来说, 每一次改动之前都先建立Issue, 这几乎不太现实, 通过`--no-ff`的节点加上相对简洁明了的注释可能是一个更明智的选择.

### 现实与理想的差距

但多数情况下, 现实场景并不满足这样的状态, 因为项目不是一个人在开发, 在我们提交的同时, 别人也在提交, 当我们的分支准备合入`master`时, `master`已经前进了, 又回到了最初那种糟糕的状态. 是去面对糟糕的状态, 还是避免糟糕的状态, 想办法修正它?

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/182726_e1afeb77_1343639.png "capture_stepup1_4_6.png")

### 向理想靠拢

如果我们在向主分支合入之前, 把这两个`commit`通过`git cherry-pick`命令**嫁接**到最新的 master 分支上, 看起来一切都变好了:laughing:. 当然, `X'`和`Y'`会被视作全新的`commit`, 他们都会有新的`sha1`.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/183310_a87b7dcc_1343639.png "capture_stepup1_4_8.png")

不过这里有个问题, 前文提过, `分支(branch)`是一个可以**向前滑动**的标签, 从`Y`到`Y'`似乎不能直接前进, 我们的分支标记怎么才能转移到`Y'`上呢?

为了达到这种理想的分支状态, 我们要经常这么干, 这一切工作似乎变得有点儿繁琐, 要执行这么多步骤才能达到分支嫁接的目的. 对的, Git 为我们提供了自动化方案, 那就是强大的 rebase.

Rebase 译作变基, 从字面上理解, rebase 命令可以改变当前分支的基点, 我们现在仅关注 rebase 功能其中的一个特性, 来达到我们分支嫁接的目的就足够了. 回到最初的场景, bugfix 分支还指向`Y`, 这是我们只要执行`git rebase master`, 即可达到目的.

我们本地的`bugfix`已经变基完成, 若它已经关联过远程分支, 那么`origin/bugfix`还处在`Y`, 我们要把本地的状态变更推送到远程, 如果接着执行`git push`, 将会报错:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/185510_3af9510e_1343639.png "QQ20190623-185455@2x.png")

可以看到, Git 服务器拒绝了我们的推送请求, 并返回了一些提示信息, 或许看到这场面, 你一下就慌了, 我辛苦写的的代码不会丢掉吧! 提示里面有`git pull`命令, 我是不是应该执行, 挽救一下!

当真正执行了`git pull`命令后, 这才是糟糕的场面!

别忘了, `git pull`暗含`git merge`语义, 这会导致一次合并, 构造的一个新的 commit `Z`, 上游分别是 bugfix `Y'`和 origin/bugfix `Y`, bugfix 指向了`Z`. 如果这时再执行了`git push`命令, 那么这糟糕的分支图就推到了服务器上, 整个团队将会看到你把分支图搞乱了, 这画面简直不可描述! (如果你脑补不出来这时分支图的样子, 下个实操案例中会演示)

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/190358_6ffce6b4_1343639.jpeg "timg (1).jpeg")

记住, 不要慌, 你已经了解了 Git 的原理, 你有能力掌控 Git, 而不是被一两个莫名的错误吓退了. 还记得刚刚使用的`git reset`命令吗? 他可以把分支强制指向任一`commit`, 我们使用`git reset --hard [Y']` 不就回到刚才的状态了吗?

好了, 假装刚才什么都没发生, 我们仔细看看服务器返回的错误, 并且思考一下问题到底出在哪里?

首先, `git push`到底在做什么? pull 和 push 是一对反义词, `git pull`是把远程分支进度同步到本地, 然后尝试将**远程分支**合并到关联的**本地分支**; `git push`在做类似的事情, 不过是相反的, 他会先把本地分支同步到远程, 然后尝试将**本地分支**合并到关联的**远程分支**. 但是, 当无法满足 fast-forward 条件时, `git push`会直接报错, 而不是尝试构造一个新的`commit`. 这就是我们刚刚遇到的错误场景.

但很显然, 我们在本地调整了分支, 并且期望把调整后的状态推送到远程, 覆盖远程分支原有的状态. 这时需要添加一个参数`git push --force`, 强制覆盖远程关联分支. 现在远程的 bugfix 分支和本地 bugfix 保持同步了, 都指向了`Y'`, team leader 可以 review 代码, 然后合入 master 了.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/192108_957f0cd5_1343639.png "capture_stepup1_4_9.png")

### 对主分支保持敬畏

上面的`git rebase`, `git push --force`看起来很有效果. 但是, 这在协作中似乎会照成一个问题: 如果大家都在 force push, 那岂不就乱套了?

所以, 应该制定一个约定: 公共分支不允许 force push. 也就是说, 公共分支只能前进. 

在常用的 Git 服务器上, 比如码云, GitLab, Github都支持分支保护功能, 我们至少要设定一个保护分支(以 master 为例), 作为**功能分支**. 该分支应该有以下特性:

- 只能前进, 也就是不允许 force push;

- 不允许直接 commit, 只能通过 merge 动作使分支前进;

- 收紧 merge 权限, 只允许部分人（leader）执行 merge;

- 只允许 merge 满足 fast-forward 条件的 commit;

- 每次 merge 前, 必须进行 code review 和持续集成(CI);

- Commit 提交者, code review 者, merge 者都要对代码变更负责.

在这种模式下, 所有团队成员以 master 分支为核心进行开发. 每个人接到开发需求后:

1. 从最新的远程 master 分支检出自己的开发分支;
2. 开发;
3. 开发结束后, 以最新的远程 master 为基点, 执行 rebase 操作, 解决掉冲突;
4. 向有 merge 权限的人提交合并请求(码云和 Github 称作 Pull Request, Gitlab 称作 Merge Request)
5. Code review 和 CI;
6. 若第5步通过, 提交被合并, master 前进; 否则回到第2步;
7. 已被合入的开发分支生命周期结束, 被删除.

关于第7步, 你没看错, 一个分支的生命周期就是这么短暂! 这取决于一个特性的大小, 可能只有几分钟, 或许有几天, 而不是像 master 分支一样永远存在.

每个人在开发过程中都应该有自己的分支, (我推荐以你的名字结尾, 这样便于标识), 这条分支是你的私有分支. 你应该对 master 分支保持敬畏, 但对于你的私有分支, 你可以任意的 force push, rebase, 甚至你不把他放到项目的公有仓库, 放到自己 fork 的私有仓库里, 这就是一张草稿纸!

### 让我们篡改历史吧!

在我们自己的分支(草稿纸)上, 我们可以相对随意地修改, 但是当提交 PR 时, 必须整理出一份干净整洁的提交记录, 这必然涉及到 commit 历史的修改. 还记得上文提到的一个强大命令吗? 对的, 就是`git rebase`!

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/233333_973d47ed_1343639.png "QQ20190623-211300@2x.png")

在macOS终端上通过`git log --oneline --graph --all`可以打印出上面的分支图, 这是我最常用的一个命令, 在linux上的表现行为可能会有点儿区别, 或许你可以尝试`git log --oneline --graph --all --decorate=short | less -r`, 或者参考`git log --help`进行调整, 来达到你想要的打印效果. 当然, 使用图形软件查看分支图也是一个很好的选择.

看, 我在开发一个订单功能, 当我开始开发的时候, master 在`c80dc1e`这个提交点, 我通过`git checkout -b feature-order-pancheng`检出一个自己的开发分支. 

我在开发过程中, 做了7次 commit, 但事实上只有4个是有意义的, 其他的几个仅仅是我在提交后立刻就发现了很明显的错误, 然后修正过来了, 这看起来就是个草稿, 如果同事 review 我的代码, 看到如此低级的错误, 似乎不太好:fearful:. 这里最好的做法就是篡改 Git 提交历史, 把 fix 类型的 commit 与上一个 commit 合并.

我们现在执行`git rebase -i c80dc1e`, `-i`代表交互模式:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/205112_dda5f5cc_1343639.png "QQ20190623-204911@2x.png")

进入了一个 vim 界面(也可能是 nano, 取决于你配置的默认编辑器), 上面列出了我们的每次提交. 注意, 这里是从上往下排列的, 上一个分支图中时从下往上排列的, 在不同的命令或软件中, 方向可能不一样.

每个 commit 最前面都是 pick 命令, 这就与我们前面使用的 cherry-pick 命令作用相似, 下面有对所有命令的解释, 你可以自行尝试.

我们看到, 有一个 fixup 命令似乎正是我们想要找的:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/210412_f811bc42_1343639.png "QQ20190623-210356@2x.png")

保存退出, 再次查看分支图:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/211759_800e0a9e_1343639.png "QQ20190623-211443@2x.png")

哈! 我们的黑历史在本地的 feature-order-pancheng 分支被抹掉了:laughing:! 然后把它推送到远程. 

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/212103_18c1cd36_1343639.png "QQ20190623-212020@2x.png")

不出意外, Git 服务器拒绝了我们的推送请求, 因为不满足 fast-forward 条件. 现在你应该不会慌了吧! 我们假装慌一把, "根据提示"执行`git pull`:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/212337_f34222d9_1343639.png "QQ20190623-212047@2x.png")

哈! 双份提交! 被老大看见说不定要挨批的! 还记得这时候应该做什么吗? 先回到 merge 前的状态, 执行`git reset --hard 395ef39`:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/211759_800e0a9e_1343639.png "QQ20190623-211443@2x.png")

然后执行`git push -f`:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/212749_b5330abd_1343639.png "QQ20190623-212706@2x.png")

之前的 origin/feature-order-pancheng 分支所处的点从图上消失了, 我们还有可能找回他吗? 哦对了, 分支名只是个标签而已, 我还记得那个点之前的`sha1`是`ccce49d`, 执行`git checkout ccce49d`, 分支又回来了, 原来只是隐藏了! 我们把这种没有任何标签的分支称谓游离分支, 他默认不会在分支图中显示, 并且会在一段时间后由 Git 进行垃圾回收, 才会真正的消失, 在此之前, 我们可以通过`git reglog`找到他们的`sha1`, 回到那个快照.

订单功能开发好了, 可以向主分支提合并请求了, 哦, 对了, master 已经前进了, 我们提 PR 之前必须先跟进. 执行`git rebase master`, `git push -f`, 然后再查看分支图:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/212822_b88413fd_1343639.png "QQ20190623-212732@2x.png")

这时就可以去提交 Pull Request 了.

当 PR 通过后, 你的分支将被合入 master 分支, 执行`git fetch`拉取远程分支信息, 然后查看分支图:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/213528_23305615_1343639.png "QQ20190623-213436@2x.png")

嗯, 一次愉快的开发结束了.

如果大家都遵守这个约定, 那么我们的分支图将会是这样:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/213831_b08fafb4_1343639.png "QQ20190623-213724@2x.png")

虽然我们在 master 分支合并上使用了`--no-ff`方式, 但是它等价于是一条直线, 这对 code review 和协作开发将十分友好.

### 那么发版呢?

相比于往 master 上 merge 提交, 项目发版是一个更谨慎的话题.

我们上面已经提到持续集成(CI), 这是一种自动化的打包和测试机制, 往往会与持续交付(CD)一起协作. 我们可以将 Git 的某些行为作为 CI/CD 的触发条件, 来达到自动化打包, 测试, 部署的能力.

我们对分支做以下规范:

- master 主功能分支;
- feature-xxx-[developer name] 特性开发分支;
- fix-xxx-[developer name] 非紧急bug修复分支;
- hotfix-xxx-[developer name] 线上紧急bug修复分支;
- dev-[date] 开发环境发布分支(或tag);
- test-[date] 测试环境发布分支(或tag);
- uat-[date] 准生产环境发布分支(或tag);
- release-[date] 线上发布分支(或tag).

在 Git 服务器中, 几乎都会提供 CI/CD 功能, CI/CD 触发条件根据正则表达式匹配`branch`或`tag`, 自动触发项目的编译, 打包, 测试, 部署等行为.

在分支管理中, `dev-[date]`分支可以由任意开发人员随时检出发布到开发环境联调; `test-[date]`, `uat-[date]`, `release-[date]`原则上必须从`master`上逐级检出, 分别测试, 若发现问题, 进行 bugfix.

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/222451_a99cbe07_1343639.png "QQ20190623-222430@2x.png")

看上去这次发版成功了, 那么这两个 bugfix commit 怎么合入到 master 呢?

我们从最新 master 切出一个 fix 分支, 并把两个补丁通过 cherry-pick 移植过来:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/223646_287d5b38_1343639.png "QQ20190623-223555@2x.png")

接下来就是 PR 流程, 当合入 master 后, 删除该 fix 分支:

![输入图片说明](https://images.gitee.com/uploads/images/2019/0623/223722_8a323e7f_1343639.png "QQ20190623-223632@2x.png")

## 游戏推荐
https://learngitbranching.js.org/?locale=zh_CN

# 谢谢 